"""Model vs Alembic migration diff checker.

Usage:
    python -m tools.model_migration_diff

Exits with status code 0 when no drift is found. Exits with 2 when drift is detected.

Algorithm (heuristic):
 - For each package under AI-TTRPG that contains an `app` package and `alembic/versions` folder:
   - Import `<pkg>.app.models` and read `Base.metadata` to discover declarative tables/columns.
   - Parse migration files under `<pkg>/alembic/versions/*.py` for `op.create_table(...)` and `op.add_column(...)` invocations and collect column names per table.
 - Report model columns that are not mentioned in migrations (create_table or add_column).

This is intentionally pragmatic (text-parsing migrations) and will work for the project's simple autogenerated migrations.
"""
Limitations:
        - Only columns defined directly in ORM class bodies are detected.
        - Columns added via mixins, inheritance, or metaprogramming are NOT detected.
        - If you add mixins or dynamic column generation, switch to a runtime check (import models and inspect Base.metadata), or extend the parser to follow mixins.
        - For most projects (including this one), static parsing is sufficient unless modeling patterns change.
from __future__ import annotations

import importlib
import importlib.util
import runpy
import os
import pkgutil
import re
import sys
from typing import Dict, List, Set


ROOT = os.path.dirname(os.path.dirname(__file__))
AI_DIR = os.path.join(ROOT, "AI-TTRPG")


def find_services() -> List[str]:
    """Return service names (folder names) under AI-TTRPG that look like Python packages."""
    services = []
    if not os.path.isdir(AI_DIR):
        return services
    for name in os.listdir(AI_DIR):
        path = os.path.join(AI_DIR, name)
        if os.path.isdir(path) and os.path.isdir(os.path.join(path, "app")) and os.path.isdir(os.path.join(path, "alembic", "versions")):
            services.append(name)
    return services


def load_model_tables(service_pkg: str) -> Dict[str, Set[str]]:
    """Import the models module for a service and return a mapping table_name -> set(column_name)."""
    result: Dict[str, Set[str]] = {}
    # Use a robust file-path based parser for models.py to avoid any import issues
    models_path = os.path.join(AI_DIR, service_pkg, 'app', 'models.py')
    if not os.path.exists(models_path):
        print(f"[WARN] models.py not found for {service_pkg} at {models_path}; skipping")
        return result

    try:
        text = open(models_path, 'r', encoding='utf-8').read()
    except Exception as e:
        print(f"[WARN] Could not read {models_path}: {e}")
        return result

    # Improved static parser: operate on class bodies to capture multi-line Column(...) patterns
    # Find class definitions and their bodies
    class_iter = list(re.finditer(r"^class\s+(?P<classname>\w+)\s*\([^\)]*\):", text, re.M))
    class_bounds: List[tuple[int, int, str]] = []  # (start, end, classname)
    for i, m in enumerate(class_iter):
        start = m.start()
        classname = m.group("classname")
        end = class_iter[i + 1].start() if i + 1 < len(class_iter) else len(text)
        class_bounds.append((start, end, classname))

    for start, end, classname in class_bounds:
        body = text[start:end]

        # Find __tablename__ in the class body
        tn = None
        m_tab = re.search(r"__tablename__\s*=\s*['\"](?P<table>[^'\"]+)['\"]", body)
        if m_tab:
            tn = m_tab.group("table")
            result.setdefault(tn, set())
        else:
            # No explicit __tablename__ -> skip ORM-less classes
            continue

        # 1) Find simple attribute assignments like: name = Column(String, ...)
        for m in re.finditer(r"^\s*(?P<attr>\w+)\s*=\s*Column\(", body, re.M):
            colname = m.group("attr")
            result.setdefault(tn, set()).add(colname)

        # 2) Find explicit Column/sa.Column calls with column name as first arg, possibly multi-line
        for m in re.finditer(r"(?:sa\.)?Column\(\s*['\"](?P<col>[^'\"]+)['\"]", body, re.S):
            result.setdefault(tn, set()).add(m.group("col"))

    return result
    


def parse_migration_columns(migration_text: str) -> Dict[str, Set[str]]:
    """Parse migration file text for created tables and added columns.

    Returns mapping table -> set(columns)
    """
    tables: Dict[str, Set[str]] = {}

    # Find op.create_table('name', ... ) blocks and extract sa.Column('col', ...)
    create_table_re = re.compile(r"op\.create_table\(\s*['\"](?P<table>[^'\"]+)['\"]\s*,(?P<body>.*?)\)\s", re.S)
    for m in create_table_re.finditer(migration_text):
        t = m.group("table")
        body = m.group("body")
        cols = set(re.findall(r"sa\.Column\(\s*['\"](?P<col>[^'\"]+)['\"]", body))
        if t not in tables:
            tables[t] = set()
        tables[t].update(cols)

    # Find op.add_column('table', sa.Column('col', ...)) calls
    add_col_re = re.compile(r"op\.add_column\(\s*['\"](?P<table>[^'\"]+)['\"]\s*,\s*sa\.Column\(\s*['\"](?P<col>[^'\"]+)['\"]", re.S)
    for m in add_col_re.finditer(migration_text):
        t = m.group("table")
        c = m.group("col")
        tables.setdefault(t, set()).add(c)

    return tables


def load_migrations(service_path: str) -> Dict[str, Set[str]]:
    """Read all migration files under service_path/alembic/versions and collect columns created/added per table."""
    migrations_dir = os.path.join(service_path, "alembic", "versions")
    result: Dict[str, Set[str]] = {}
    if not os.path.isdir(migrations_dir):
        return result
    for fname in os.listdir(migrations_dir):
        if not fname.endswith('.py'):
            continue
        full = os.path.join(migrations_dir, fname)
        try:
            with open(full, 'r', encoding='utf-8') as f:
                text = f.read()
        except Exception as e:
            print(f"[WARN] Could not read migration {full}: {e}")
            continue

        parsed = parse_migration_columns(text)
        for table, cols in parsed.items():
            result.setdefault(table, set()).update(cols)

    return result


def run_check() -> int:
    services = find_services()
    if not services:
        print("No services with app+alembic found under AI-TTRPG/")
        return 0

    overall_ok = True

    for svc in services:
        pkg = f"AI-TTRPG.{svc}"
        svc_path = os.path.join(AI_DIR, svc)
        print(f"\nChecking service: {svc} ({pkg})")

        # load_model_tables expects the service folder name (svc)
        model_tables = load_model_tables(svc)
        migration_tables = load_migrations(svc_path)

        # For each model table, compare columns
        for table, model_cols in sorted(model_tables.items()):
            mig_cols = migration_tables.get(table, set())
            missing = model_cols - mig_cols
            if missing:
                overall_ok = False
                print(f"[DRIFT] Service {svc} table '{table}' has model columns not in migrations:")
                for c in sorted(missing):
                    print(f"  - {c}")

        # Also check for tables defined in migrations but not in models (informational)
        for table in sorted(set(migration_tables) - set(model_tables)):
            print(f"[INFO] Migration creates table '{table}' but no ORM model found in {svc} (ok)")

    if overall_ok:
        print("\nNo model-vs-migration drift detected.")
        return 0
    else:
        print("\nModel-vs-migration drift detected. Create Alembic revisions to match models.")
        return 2


if __name__ == '__main__':
    rc = run_check()
    sys.exit(rc)
