import os

file_path = r"c:\Users\krazy\Documents\GitHub\ShatterlandsTTRPGAI\AI-TTRPG\monolith\modules\story_pkg\combat_handler.py"

with open(file_path, "r", encoding="utf-8") as f:
    lines = f.readlines()

# 1. Find the cut-off point in _grant_combat_rewards
cut_off_index = -1
for i, line in enumerate(lines):
    if "for pid in player_ids:" in line and "try:" in lines[i+1]:
        cut_off_index = i + 2 # The line after 'try:'
        break

if cut_off_index == -1:
    print("Could not find the cut-off point in _grant_combat_rewards")
    # Fallback: look for the arguments of summon_creature
    for i, line in enumerate(lines):
        if "db: Session," in line and "combat: models.CombatEncounter," in lines[i+1]:
             cut_off_index = i
             break

if cut_off_index == -1:
    print("CRITICAL FAILURE: Could not locate insertion point.")
    exit(1)

# 2. Prepare the missing/fixed content
missing_content = [
    '            services.award_xp(db, pid, xp_reward)\n',
    '            log.append(f"Player {pid} gained {xp_reward} XP.")\n',
    '        except Exception as e:\n',
    '            logger.error(f"Failed to award XP to {pid}: {e}")\n',
    '\n',
    'def _handle_effect_aoe_status_apply(\n',
    '    db: Session,\n',
    '    combat: models.CombatEncounter,\n',
    '    actor_id: str, target_id: str, attacker_context: Dict, defender_context: Dict, log: List[str], effect: Dict) -> bool:\n',
    '    """Handles AoE application of a status (no roll) (e.g., Cunning T4)."""\n',
    '    status_id = effect.get("status_id")\n',
    '    shape = effect.get("shape", "radius")\n',
    '    range_m = effect.get("range", 5)\n',
    '\n',
    '    if not status_id: return False\n',
    '\n',
    '    # Assuming AoE buffs target friends by default\n',
    '    aoe_targets = _get_targets_in_aoe(combat, target_id, shape, range_m, target_type="ally_or_self")\n',
    '\n',
    '    for p_actor_id, p_context in aoe_targets:\n',
    '        services.apply_status_to_target(p_actor_id, status_id)\n',
    '        log.append(f"  -> {p_actor_id} gains {status_id}.")\n',
    '\n',
    '    log.append(f"AoE status \'{status_id}\' applied to {len(aoe_targets)} targets in the {shape}.")\n',
    '    return True\n',
    '\n',
    'def _handle_effect_aoe_composure_damage_roll(\n',
    '    db: Session,\n',
    '    combat: models.CombatEncounter,\n',
    '    actor_id: str, target_id: str, attacker_context: Dict, defender_context: Dict, log: List[str], effect: Dict) -> bool:\n',
    '    """Handles AoE Composure damage with individual saves for half damage (e.g., Spirit T4)."""\n',
    '    amount_str = effect.get("amount", "1d6")\n',
    '    shape = effect.get("shape", "radius")\n',
    '    range_m = effect.get("range", 5)\n',
    '    save_stat = effect.get("save_stat")\n',
    '    dc = effect.get("dc", 14)\n',
    '\n',
    '    if not save_stat: return False\n',
    '\n',
    '    aoe_targets = _get_targets_in_aoe(combat, target_id, shape, range_m, target_type="enemy")\n',
    '    total_damage = 0\n',
    '\n',
    '    for p_actor_id, p_context in aoe_targets:\n',
    '        stat_score = get_stat_score(p_context, save_stat)\n',
    '        stat_mod = rules_core.calculate_modifier(stat_score)\n',
    '        roll = random.randint(1, 20)\n',
    '        total = roll + stat_mod\n',
    '        damage_amount = _roll_dice_string(amount_str)\n',
    '        final_damage = damage_amount\n',
    '\n',
    '        if total >= dc:\n',
    '            final_damage = damage_amount // 2\n',
    '\n',
    '        total_damage += final_damage\n',
    '        if final_damage > 0:\n',
    '            if p_actor_id.startswith("player_"):\n',
    '                services.apply_composure_damage_to_character(p_actor_id, final_damage)\n',
    '            elif p_actor_id.startswith("npc_"):\n',
    '                services.apply_composure_damage_to_npc(int(p_actor_id.split("_")[1]), final_damage)\n',
    '\n',
    '            log.append(f" -> Applied {final_damage} Composure damage to {p_actor_id}.")\n',
    '\n',
    '    log.append(f"AoE Composure damage applied to {len(aoe_targets)} targets, total damage: {total_damage}.")\n',
    '    return True\n',
    '\n',
    'def _handle_effect_aoe_heal(\n',
    '    db: Session,\n',
    '    combat: models.CombatEncounter,\n',
    '    actor_id: str, target_id: str, attacker_context: Dict, defender_context: Dict, log: List[str], effect: Dict) -> bool:\n',
    '    """Handles AoE healing for HP (e.g., Biomancy T8)."""\n',
    '    amount_str = effect.get("amount", "1d6")\n',
    '    shape = effect.get("shape", "radius")\n',
    '    range_m = effect.get("range", 5)\n',
    '\n',
    '    aoe_targets = _get_targets_in_aoe(combat, target_id, shape, range_m, target_type="ally_or_self")\n',
    '    total_healed = 0\n',
    '\n',
    '    for p_actor_id, p_context in aoe_targets:\n',
    '        heal_amount = _roll_dice_string(amount_str)\n',
    '        total_healed += heal_amount\n',
    '\n',
    '        if p_actor_id.startswith("player_"):\n',
    '            services.apply_healing_to_character(p_actor_id, heal_amount)\n',
    '        elif p_actor_id.startswith("npc_"):\n',
    '            try:\n',
    '                npc_instance_id = int(p_actor_id.split("_")[1])\n',
    '                new_hp = min(\n',
    '                    p_context.get("current_hp", 0) + heal_amount,\n',
    '                    p_context.get("max_hp", 99)\n',
    '                )\n',
    '                services.world_api.update_npc_state(npc_instance_id, {"current_hp": new_hp})\n',
    '            except Exception as e:\n',
    '                log.append(f"Failed to apply AoE heal to {p_actor_id}: {e}")\n',
    '\n',
    '        log.append(f"  -> {p_actor_id} healed for {heal_amount} HP.")\n',
    '\n',
    '    log.append(f"AoE heal applied to {len(aoe_targets)} targets, total healed: {total_healed} HP.")\n',
    '    return True\n',
    '\n',
    'def _handle_effect_aoe_damage(\n',
    '    db: Session,\n',
    '    combat: models.CombatEncounter,\n',
    '    actor_id: str,\n',
    '    target_id: str, # This is the epicenter of the AoE\n',
    '    attacker_context: Dict,\n',
    '    defender_context: Dict, # Context of the epicenter target\n',
    '    log: List[str],\n',
    '    effect: Dict\n',
    ') -> bool:\n',
    '    """\n',
    '    Handles effects that deal AoE damage.\n',
    '    """\n',
    '    damage_str = effect.get("damage", "1d8")\n',
    '    damage_type = effect.get("damage_type", "elemental")\n',
    '    shape = effect.get("shape", "radius")\n',
    '    aoe_range = effect.get("range", 2) # e.g., 2m radius\n',
    '    target_faction = effect.get("target_faction", "enemy") # "enemy" or "ally"\n',
    '\n',
    '    log.append(f"{actor_id} unleashes an AoE {shape} for {damage_str} {damage_type} damage around {target_id}!")\n',
    '\n',
    '    # 1. Get epicenter coordinates\n',
    '    epicenter_coords = _get_actor_coords(defender_context)\n',
    '    if not epicenter_coords:\n',
    '        log.append(f"Could not find epicenter coordinates for target {target_id}. Effect fails.")\n',
    '        return False\n',
    '\n',
    '    # 2. Roll damage ONCE\n',
    '    damage_amount = _roll_dice_string(damage_str)\n',
    '    if damage_amount <= 0:\n',
    '        log.append("The effect fizzles and deals no damage.")\n',
    '        return True # The ability was used, it just did no damage\n',
    '\n',
    '    # 3. Find all targets in combat\n',
    '    all_targets = []\n',
    '    actor_type_prefix = "player_" if target_faction == "ally" else "npc_"\n',
    '    if target_faction == "ally":\n',
    '        actor_type_prefix = "player_"\n',
    '    else:\n',
    '        # Default to targeting enemies of the caster\n',
    '        actor_type_prefix = "npc_" if actor_id.startswith("player_") else "player_"\n',
    '\n',
    '    for p in combat.participants:\n',
    '        if p.actor_id.startswith(actor_type_prefix):\n',
    '            try:\n',
    '                _, p_context = get_actor_context(p.actor_id)\n',
    '                if p_context.get("current_hp", 0) > 0:\n',
    '                    all_targets.append(p_context)\n',
    '            except HTTPException:\n',
    '                continue\n',
    '\n',
    '    # 4. Apply damage to targets in range\n',
    '    targets_hit = 0\n',
    '    for target_ctx in all_targets:\n',
    '        target_coords = _get_actor_coords(target_ctx)\n',
    '        distance = _calculate_distance(epicenter_coords, target_coords)\n',
    '\n',
    '        if distance <= aoe_range:\n',
    '            # Target is in range\n',
    '            targets_hit += 1\n',
    '            target_hit_id = target_ctx.get("id")\n',
    '            log.append(f"The blast hits {target_hit_id} for {damage_amount} damage!")\n',
    '\n',
    '            # Apply damage (simplified, ignores armor for AoE)\n',
    '            if target_hit_id.startswith("player_"):\n',
    '                services.apply_damage_to_character(target_hit_id, damage_amount)\n',
    '            elif target_hit_id.startswith("npc_"):\n',
    '                try:\n',
    '                    npc_instance_id = int(target_hit_id.split("_")[1])\n',
    '                    new_hp = target_ctx.get("current_hp", 0) - damage_amount\n',
    '                    services.apply_damage_to_npc(npc_instance_id, new_hp)\n',
    '                except Exception as e:\n',
    '                    log.append(f"Failed to apply AoE damage to {target_hit_id}: {e}")\n',
    '\n',
    '    if targets_hit == 0:\n',
    '        log.append("...but nothing was in range!")\n',
    '\n',
    '    return True\n',
    '\n',
    '# --- Utility / Special Handlers ---\n',
    '\n',
    'def _handle_effect_summon_creature(\n'
]

# 3. Reconstruct the file
new_lines = lines[:cut_off_index] + missing_content + lines[cut_off_index:]

with open(file_path, "w", encoding="utf-8") as f:
    f.writelines(new_lines)

print("Successfully restored combat_handler.py")
